## 풀이 & 테스트 코드
- https://github.com/cri-kim/BlogPractice/tree/main/computer-science/java-algorithm-solution/src/main/java/grid
- 
## 섬의 개수
1. 풀이 시간 : 20분
2. 동작
- dfs를 활용하여 문제를 풀었다.
- 섬의 상하좌우, 성이 아닌 곳을 탈출 조건문으로 만들었다.
- 땅이 있는 곳을 탐색하고, 땅에 대한 탐색이 끝나면 num을 올린다.
- num(요구 값)을 반환한다,

## 전화 번호 문자 조합
1. 풀이 시간 : X 
2. 동작
- 전화기 숫자에 따른 리스트 생성(phone = {“”,””,”abc”,…})
- 입력된 숫자의 값(digits)가 존재하면 dfs 탐색시작
- 탐색 횟수가 입력받은 숫자의 길이만큼 되면 dfs 중지
 
## 순열
1. 풀이 시간 : X
2. 동작
- dfs + backtracking으로 문제 풀이
-서로 다른 n개의 원소에서 r개를 중복 없이 순서에 상관 있게 선택하는 것을 순열이라고 한다.

## 조합
1. 풀이 시간 : 20분
2. 동작
- 서로 다른 n개의 원소에서 가지는 집합을 순서에 상관없이 r개의 원소로 이루어진 집합을 만드는 경우의 수를 뜻 한다.
- 집합의 원소 갯수에 대한 제한(target)을 조건으로 넣는다.
- 이 값을 target과 비교한다.
- dfs로 모든 경우의 수를 탐색한다.

## 조합의 합
1. 풀이 시간 :  20분
2. 동작
- 상위 조합의 문제를 기반으로 문제를 풀었다,
- 스트림을 통해 int list의 값의 합을 구한다.

## 부분 집합
1. 풀이 시간 : 16분
2. 동작
- 위의 순열 문제풀이에서, 집합의 길이가 될 r을 0부터 nums의 길이만큼 진행한다. 
- backtracking으로 문제를 해결한다.

## 일정 재구성
1. 풀이 시간 : X
2. 동작
- Map, PriorityQueue를 사용하여 풀 수 있다.

## 코스 스케쥴
1. 풀이 시간 : X
